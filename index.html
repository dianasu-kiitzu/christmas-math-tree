<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <title>üéÑ ËÅñË™ïÊï∏Â≠∏Ê®π - Âø´Ê®ÇÂ≠∏Êï∏Â≠∏</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #0f172a; overscroll-behavior: none; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes bounce-short {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -60%) scale(1.1); }
        }
        .animate-bounce-short { animation: bounce-short 0.5s ease-in-out; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const RefreshCw = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
        );
        const Trophy = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M12 14.66V17"/><path d="M12 2v20"/><path d="M12 17a5 5 0 0 1-5-5V7h10v5a5 5 0 0 1-5 5Z"/></svg>
        );
        const Star = ({ size = 24, fill = "none", color = "currentColor", strokeWidth = 2, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke={color} strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>
        );
        const BookOpen = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
        );

        // --- Main Component ---
        const MathTreeGame = () => {
            const [problems, setProblems] = useState([]);
            const [answers, setAnswers] = useState([]);
            const [completed, setCompleted] = useState(false);
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
            const [feedback, setFeedback] = useState(null);
            
            // Grade Level State
            const [gradeLevel, setGradeLevel] = useState('g1');

            const treeRef = useRef(null);
            const slotRefs = useRef({});
            
            // New Refs for Touch Handling
            const dragStartPos = useRef({ x: 0, y: 0 });
            const pendingDrag = useRef(null);

            // Grade Definitions
            const GRADE_LEVELS = [
                { id: 'k', name: 'ÂπºÁ®öÂúíÂ§ßÁè≠' },
                { id: 'g1', name: 'ÂúãÂ∞è‰∏ÄÂπ¥Á¥ö' },
                { id: 'g2', name: 'ÂúãÂ∞è‰∫åÂπ¥Á¥ö' },
                { id: 'g3', name: 'ÂúãÂ∞è‰∏âÂπ¥Á¥ö' },
                { id: 'g4', name: 'ÂúãÂ∞èÂõõÂπ¥Á¥ö' },
                { id: 'g5', name: 'ÂúãÂ∞è‰∫îÂπ¥Á¥ö' },
                { id: 'g6', name: 'ÂúãÂ∞èÂÖ≠Âπ¥Á¥ö' },
            ];

            // Configuration
            const TREE_SLOTS_POS = [
                { id: 0, top: '20%', left: '50%' },
                { id: 1, top: '35%', left: '40%' },
                { id: 2, top: '35%', left: '60%' },
                { id: 3, top: '50%', left: '30%' },
                { id: 4, top: '50%', left: '50%' },
                { id: 5, top: '50%', left: '70%' },
                { id: 6, top: '68%', left: '20%' },
                { id: 7, top: '68%', left: '40%' },
                { id: 8, top: '68%', left: '60%' },
                { id: 9, top: '68%', left: '80%' },
            ];

            const BALL_STYLES = [
                { bg: 'from-red-400 to-red-600', border: 'border-red-300' },
                { bg: 'from-blue-400 to-blue-600', border: 'border-blue-300' },
                { bg: 'from-green-400 to-green-600', border: 'border-green-300' },
                { bg: 'from-purple-400 to-purple-600', border: 'border-purple-300' },
                { bg: 'from-orange-400 to-orange-600', border: 'border-orange-300' },
                { bg: 'from-pink-400 to-pink-600', border: 'border-pink-300' },
                { bg: 'from-teal-400 to-teal-600', border: 'border-teal-300' },
                { bg: 'from-indigo-400 to-indigo-600', border: 'border-indigo-300' },
                { bg: 'from-rose-400 to-rose-600', border: 'border-rose-300' },
                { bg: 'from-cyan-400 to-cyan-600', border: 'border-cyan-300' },
            ];

            // Restart game when grade level changes
            useEffect(() => {
                startNewGame();
            }, [gradeLevel]);

            // --- Math Generation Logic (Aligned with Syllabus) ---
            const generateProblemForGrade = (grade) => {
                let num1, num2, operator, answer, question;
                const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
                const roundOne = (num) => Math.round(num * 10) / 10; // Round to 1 decimal

                switch(grade) {
                    case 'k': 
                        // ÂπºÁ®öÂúí: 10‰ª•ÂÖßÂä†Ê≥ï
                        num1 = rand(1, 5);
                        num2 = rand(1, 5);
                        operator = '+';
                        answer = num1 + num2;
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    case 'g1': 
                        // ‰∏ÄÂπ¥Á¥ö (Stage 1): 20~50‰ª•ÂÖßÂä†Ê∏õÔºåÂª∫Á´ã‰ΩçÂÄºËàáÂä†Ê∏õÈÅãÁÆóÊÑèÁæ©
                        operator = Math.random() > 0.5 ? '+' : '-';
                        if (operator === '+') {
                            num1 = rand(1, 25);
                            num2 = rand(1, 20);
                            answer = num1 + num2;
                        } else {
                            num1 = rand(10, 50);
                            num2 = rand(1, num1);
                            answer = num1 - num2;
                        }
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    case 'g2': 
                        // ‰∫åÂπ¥Á¥ö (Stage 1): 1000‰ª•ÂÖßÂä†Ê∏õÔºåÂπæ‰ΩïËàáÈå¢Âπ£Âü∫Á§é(Ê≠§ÈÅäÊà≤‰ª•ÈÅãÁÆóÁÇ∫‰∏ª)
                        // ÈÄôË£°ÂèØ‰ª•Âä†ÂÖ•Á∞°ÂñÆÁöÑ‰πòÊ≥ïÊ¶ÇÂøµ(2, 5, 10ÁöÑ‰πòÊ≥ï)
                        const typeG2 = Math.random();
                        if (typeG2 < 0.4) {
                            operator = '+'; num1 = rand(10, 500); num2 = rand(10, 400); answer = num1 + num2;
                        } else if (typeG2 < 0.8) {
                            operator = '-'; num1 = rand(50, 999); num2 = rand(10, num1); answer = num1 - num2;
                        } else {
                            // Âü∫Á§é‰πòÊ≥ï (2, 5, 10)
                            operator = '√ó'; 
                            let base = [2, 5, 10][Math.floor(Math.random()*3)];
                            num1 = base; num2 = rand(1, 9); answer = num1 * num2;
                        }
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    case 'g3': 
                        // ‰∏âÂπ¥Á¥ö (Stage 2): Èô§Ê≥ï„ÄÅÂä†Ê∏õÊ≥ïÁ≤æÁÜü„ÄÅ‰πòÊ≥ï(2‰Ωçx1‰Ωç)
                        const typeG3 = Math.random();
                        if (typeG3 < 0.3) {
                            operator = '+'; num1 = rand(100, 2000); num2 = rand(100, 2000); answer = num1 + num2;
                        } else if (typeG3 < 0.6) {
                            operator = '-'; num1 = rand(500, 3000); num2 = rand(100, num1); answer = num1 - num2;
                        } else if (typeG3 < 0.8) {
                            operator = '√ó'; num1 = rand(11, 99); num2 = rand(2, 9); answer = num1 * num2;
                        } else {
                            operator = '√∑'; 
                            num2 = rand(2, 9); // Èô§Êï∏
                            answer = rand(10, 50); // ÂïÜ
                            num1 = num2 * answer; // Ë¢´Èô§Êï∏
                        }
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    case 'g4': 
                        // ÂõõÂπ¥Á¥ö (Stage 2): Â∞èÊï∏Âä†Ê∏õ„ÄÅÊï¥Êï∏Èô§Ê≥ï„ÄÅÂ§ßÊï∏ÈÅãÁÆó
                        const typeG4 = Math.random();
                        if (typeG4 < 0.4) {
                            // Â∞èÊï∏Âä†Ê∏õ (‰∏Ä‰ΩçÂ∞èÊï∏)
                            operator = Math.random() > 0.5 ? '+' : '-';
                            if (operator === '+') {
                                num1 = rand(1, 99) / 10;
                                num2 = rand(1, 99) / 10;
                                answer = roundOne(num1 + num2);
                            } else {
                                num1 = rand(20, 150) / 10;
                                num2 = rand(10, num1 * 10) / 10;
                                answer = roundOne(num1 - num2);
                            }
                        } else if (typeG4 < 0.7) {
                            // ‰πòÊ≥ï (3‰Ωç x 1‰Ωç)
                            operator = '√ó'; num1 = rand(100, 500); num2 = rand(2, 9); answer = num1 * num2;
                        } else {
                            // Èô§Ê≥ï (3‰Ωç / 1‰Ωç)
                            operator = '√∑';
                            num2 = rand(2, 9);
                            answer = rand(50, 150);
                            num1 = num2 * answer;
                        }
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    case 'g5': 
                        // ‰∫îÂπ¥Á¥ö (Stage 3): ÂàÜÊï∏Â∞èÊï∏‰πòÈô§„ÄÅÁï∞ÂàÜÊØç(ËºÉÈõ£ÂëàÁèæÂÖà‰ª•ÈÅãÁÆóÁÇ∫‰∏ª)„ÄÅÂ∞èÊï∏‰πòÊ≥ï
                        const typeG5 = Math.random();
                        if (typeG5 < 0.4) {
                            // Â∞èÊï∏‰πòÊ≥ï (Êï¥Êï∏ x ‰∏Ä‰ΩçÂ∞èÊï∏)
                            operator = '√ó'; 
                            num1 = rand(2, 20); 
                            num2 = rand(1, 9) / 10; // 0.1 ~ 0.9
                            answer = roundOne(num1 * num2);
                        } else if (typeG5 < 0.7) {
                            // Ê∑∑ÂêàÈÅãÁÆó: A + B x C (È°ØÁ§∫ÁÇ∫Â≠ó‰∏≤)
                            let n1 = rand(2, 10);
                            let n2 = rand(2, 9);
                            let n3 = rand(2, 10);
                            answer = n1 + (n2 * n3);
                            question = `${n1} + ${n2} √ó ${n3}`;
                            return { question, answer }; // Early return for special format
                        } else {
                            // Â§ßÊï∏Èô§Ê≥ï
                            operator = '√∑';
                            num2 = rand(11, 50);
                            answer = rand(11, 50);
                            num1 = num2 * answer;
                        }
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    case 'g6': 
                        // ÂÖ≠Âπ¥Á¥ö (Stage 3): È´îÁ©çÊ¶ÇÂøµ(ËΩâÂåñÁÇ∫‰∏âÊï∏Áõ∏‰πò)„ÄÅÁôæÂàÜÊØî„ÄÅÂõõÂâáÊ∑∑Âêà
                        const typeG6 = Math.random();
                        if (typeG6 < 0.3) {
                            // Á∞°ÂñÆÁôæÂàÜÊØî: 50% x 200
                            let p = [10, 20, 25, 50][Math.floor(Math.random() * 4)];
                            let base = rand(2, 20) * 10; // 20 ~ 200
                            answer = Math.round(base * (p / 100));
                            question = `${p}% √ó ${base}`;
                            return { question, answer };
                        } else if (typeG6 < 0.6) {
                            // Â∞èÊï∏Èô§Ê≥ï (Êï¥Èô§)
                            operator = '√∑';
                            num2 = rand(2, 8) / 10; // 0.2 ~ 0.8
                            answer = rand(10, 50); 
                            num1 = roundOne(num2 * answer); // Á¢∫‰øùÊòØÊï¥Êï∏ÊàñÁ∞°ÂñÆÂ∞èÊï∏
                        } else {
                            // ÂõõÂâáÈÅãÁÆó (Êã¨Ëôü)
                            let n1 = rand(5, 20);
                            let n2 = rand(1, 5);
                            let n3 = rand(2, 5);
                            // (A - B) x C
                            answer = (n1 - n2) * n3;
                            question = `(${n1} - ${n2}) √ó ${n3}`;
                            return { question, answer };
                        }
                        question = `${num1} ${operator} ${num2}`;
                        break;

                    default:
                        num1 = 1; num2 = 1; operator='+'; answer=2; question = "1 + 1";
                }
                
                return { question, answer };
            };

            const startNewGame = () => {
                const newProblems = [];
                const newAnswers = [];
                const usedAnswers = new Set();
                const shuffledColors = [...BALL_STYLES].sort(() => 0.5 - Math.random());

                for (let i = 0; i < 10; i++) {
                    let prob;
                    let safety = 0;
                    
                    // Generate unique answers
                    do {
                        prob = generateProblemForGrade(gradeLevel);
                        safety++;
                    } while (usedAnswers.has(prob.answer) && safety < 50);

                    usedAnswers.add(prob.answer);
                    
                    newProblems.push({
                        id: i,
                        question: prob.question,
                        answer: prob.answer,
                        solved: false,
                        ...TREE_SLOTS_POS[i]
                    });
                    newAnswers.push({
                        id: `ans-${i}`,
                        value: prob.answer,
                        problemId: i,
                        currentSlot: null,
                        isDragging: false,
                        colorStyle: shuffledColors[i % shuffledColors.length],
                    });
                }

                setProblems(newProblems);
                setAnswers(newAnswers);
                setCompleted(false);
                setFeedback(null);
            };

            // --- Drag and Drop ---
            const handlePointerDown = (e, answerId) => {
                if (!e.touches) {
                    e.preventDefault();
                    setDraggedItem(answerId);
                    setDragPosition({ x: e.clientX, y: e.clientY });
                    setAnswers(prev => prev.map(a => a.id === answerId ? { ...a, isDragging: true } : a));
                    return;
                }
                const touch = e.touches[0];
                dragStartPos.current = { x: touch.clientX, y: touch.clientY };
                pendingDrag.current = answerId;
            };

            const handlePointerMove = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                if (draggedItem) {
                    if (e.cancelable) e.preventDefault(); 
                    setDragPosition({ x: clientX, y: clientY });
                    return;
                }

                if (pendingDrag.current && e.touches) {
                    const startX = dragStartPos.current.x;
                    const startY = dragStartPos.current.y;
                    const deltaX = Math.abs(clientX - startX);
                    const deltaY = Math.abs(clientY - startY);

                    if (deltaX > 5 || deltaY > 5) {
                        if (deltaY > deltaX) {
                             if (e.cancelable) e.preventDefault();
                             const ansId = pendingDrag.current;
                             setDraggedItem(ansId);
                             setDragPosition({ x: clientX, y: clientY });
                             setAnswers(prev => prev.map(a => a.id === ansId ? { ...a, isDragging: true } : a));
                             pendingDrag.current = null;
                        } else {
                            pendingDrag.current = null;
                        }
                    }
                }
            };

            const handlePointerUp = (e) => {
                pendingDrag.current = null; 
                
                if (!draggedItem) return;

                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                
                let targetSlotId = null;
                Object.keys(slotRefs.current).forEach((key) => {
                    const slotEl = slotRefs.current[key];
                    if (slotEl) {
                        const rect = slotEl.getBoundingClientRect();
                        const distance = Math.hypot(
                            rect.x + rect.width / 2 - clientX,
                            rect.y + rect.height / 2 - clientY
                        );
                        if (distance < 50) targetSlotId = parseInt(key);
                    }
                });

                if (targetSlotId !== null) {
                    checkAnswer(draggedItem, targetSlotId);
                } else {
                    resetDrag(draggedItem);
                }
                setDraggedItem(null);
            };

            const resetDrag = (id) => {
                setAnswers(prev => prev.map(a => a.id === id ? { ...a, isDragging: false } : a));
            };

            const checkAnswer = (ansId, slotId) => {
                const answerObj = answers.find(a => a.id === ansId);
                const problemObj = problems.find(p => p.id === slotId);

                if (problemObj.solved) {
                    resetDrag(ansId);
                    return;
                }

                // Use simple loose equality for string/number match (e.g. "3.8" == 3.8)
                // eslint-disable-next-line eqeqeq
                if (answerObj.value == problemObj.answer) {
                    playSound('success');
                    setAnswers(prev => prev.map(a => 
                        a.id === ansId ? { ...a, isDragging: false, currentSlot: slotId } : a
                    ));
                    setProblems(prev => prev.map(p => 
                        p.id === slotId ? { ...p, solved: true } : p
                    ));
                    setFeedback('correct');
                    setTimeout(() => setFeedback(null), 1000);
                } else {
                    playSound('error');
                    setFeedback('wrong');
                    setTimeout(() => setFeedback(null), 1000);
                    resetDrag(ansId);
                }
            };

            useEffect(() => {
                if (problems.length > 0 && problems.every(p => p.solved)) {
                    setCompleted(true);
                    playSound('win');
                }
            }, [problems]);

            const playSound = (type) => {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return;
                const ctx = new AudioContext();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);

                if (type === 'success') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(500, ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1000, ctx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.3);
                } else if (type === 'error') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(200, ctx.currentTime);
                    osc.frequency.linearRampToValueAtTime(100, ctx.currentTime + 0.2);
                    gain.gain.setValueAtTime(0.2, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                    osc.start();
                    osc.stop(ctx.currentTime + 0.2);
                } else if (type === 'win') {
                    const now = ctx.currentTime;
                    [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                        const osc2 = ctx.createOscillator();
                        const gain2 = ctx.createGain();
                        osc2.connect(gain2);
                        gain2.connect(ctx.destination);
                        osc2.type = 'triangle';
                        osc2.frequency.value = freq;
                        gain2.gain.setValueAtTime(0.1, now + i * 0.1);
                        gain2.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.5);
                        osc2.start(now + i * 0.1);
                        osc2.stop(now + i * 0.1 + 0.5);
                    });
                }
            };

            const getPlacedStyle = (ans) => {
                if (ans.currentSlot !== null) {
                    const slot = problems.find(p => p.id === ans.currentSlot);
                    return {
                        position: 'absolute',
                        left: slot.left,
                        top: slot.top,
                        transform: 'translate(-50%, -50%)',
                        zIndex: 10,
                        transition: 'all 0.3s ease-out'
                    };
                }
                return {};
            };

            const unplacedAnswers = answers.filter(a => a.currentSlot === null);

            return (
                <div 
                    className="w-full h-screen bg-slate-900 overflow-hidden flex flex-col items-center select-none"
                    onTouchMove={handlePointerMove}
                    onTouchEnd={handlePointerUp}
                    onMouseMove={handlePointerMove}
                    onMouseUp={handlePointerUp}
                >
                    <div className="absolute inset-0 pointer-events-none opacity-20">
                        {[...Array(20)].map((_, i) => (
                            <div 
                                key={i}
                                className="absolute bg-white rounded-full animate-pulse"
                                style={{
                                    width: Math.random() * 5 + 2 + 'px',
                                    height: Math.random() * 5 + 2 + 'px',
                                    top: Math.random() * 100 + '%',
                                    left: Math.random() * 100 + '%',
                                    animationDuration: Math.random() * 3 + 2 + 's'
                                }}
                            />
                        ))}
                    </div>

                    <div className="z-10 w-full p-2 md:p-4 flex justify-between items-center bg-slate-800/80 text-white shadow-lg border-b border-white/10 shrink-0">
                        <h1 className="text-lg md:text-2xl font-bold flex items-center gap-2 text-green-400">
                            <span className="text-xl md:text-2xl">üéÑ</span> 
                            <span className="hidden md:inline">ËÅñË™ïÊï∏Â≠∏Ê®π</span>
                            <span className="md:hidden">Êï∏Â≠∏Ê®π</span>
                        </h1>
                        <div className="flex gap-2 items-center">
                            {/* Grade Selector */}
                            <div className="relative">
                                <BookOpen className="absolute left-2 top-1/2 -translate-y-1/2 text-slate-400" size={16} />
                                <select 
                                    value={gradeLevel}
                                    onChange={(e) => setGradeLevel(e.target.value)}
                                    className="pl-8 pr-3 py-1.5 bg-slate-700 hover:bg-slate-600 rounded-full font-bold shadow-md text-xs md:text-base appearance-none focus:outline-none focus:ring-2 focus:ring-indigo-500 cursor-pointer"
                                >
                                    {GRADE_LEVELS.map(g => (
                                        <option key={g.id} value={g.id}>{g.name}</option>
                                    ))}
                                </select>
                            </div>

                            <button 
                                onClick={startNewGame}
                                className="flex items-center gap-1 md:gap-2 px-3 py-1.5 bg-red-600 hover:bg-red-500 rounded-full font-bold shadow-md text-xs md:text-base"
                            >
                                <RefreshCw size={16} /> ÈáçÁé©
                            </button>
                        </div>
                    </div>

                    <div className="flex-1 w-full max-w-6xl flex flex-col md:flex-row relative overflow-hidden">
                        <div className="hidden md:flex w-1/4 h-full flex-col items-center justify-center gap-4 py-4 z-20 touch-none">
                            <div className="flex flex-col gap-3 w-full items-center overflow-y-auto hide-scrollbar pb-20">
                                {unplacedAnswers.filter((_, i) => i % 2 === 0).map(ans => (
                                    <DraggableBall key={ans.id} ans={ans} draggedItem={draggedItem} onDown={handlePointerDown} />
                                ))}
                            </div>
                        </div>

                        <div className="w-full md:w-2/4 h-[65%] md:h-full relative flex items-center justify-center shrink-0 touch-none" ref={treeRef}>
                            <div className="relative w-full h-full max-h-[80vh] aspect-[2/3] md:aspect-[2/3] flex items-center justify-center">
                                <div className={`absolute top-[8%] left-1/2 -translate-x-1/2 z-10 transition-all duration-500 ${completed ? 'scale-150 drop-shadow-[0_0_20px_rgba(255,255,0,0.8)]' : 'scale-100'}`}>
                                    <Star size={40} fill={completed ? "gold" : "#fbbf24"} color="#b45309" strokeWidth={2} className="animate-pulse" />
                                </div>
                                <svg viewBox="0 0 200 300" className="w-full h-full drop-shadow-2xl">
                                    <path d="M100 20 L 10 250 L 190 250 Z" fill="#15803d" stroke="#14532d" strokeWidth="3" />
                                    <path d="M30 200 Q 100 220 170 200" fill="none" stroke="#fbbf24" strokeWidth="2" strokeDasharray="5,5" opacity="0.6"/>
                                    <path d="M55 140 Q 100 160 145 140" fill="none" stroke="#fbbf24" strokeWidth="2" strokeDasharray="5,5" opacity="0.6"/>
                                    <path d="M75 80 Q 100 90 125 80" fill="none" stroke="#fbbf24" strokeWidth="2" strokeDasharray="5,5" opacity="0.6"/>
                                    <rect x="85" y="250" width="30" height="40" fill="#78350f" />
                                </svg>
                                {problems.map(prob => (
                                    <div key={prob.id} ref={el => slotRefs.current[prob.id] = el}
                                        className={`absolute w-12 h-12 md:w-20 md:h-20 rounded-full flex items-center justify-center text-center transform -translate-x-1/2 -translate-y-1/2 border-[3px] md:border-4 transition-all duration-300 ${prob.solved ? 'bg-yellow-100 border-yellow-400' : 'bg-green-800/80 border-green-600'}`}
                                        style={{ top: prob.top, left: prob.left }}>
                                        {!prob.solved && (
                                            <span className={`text-white font-bold drop-shadow-md whitespace-nowrap 
                                                ${prob.question.length > 9 ? 'text-[9px] md:text-sm' : 
                                                  prob.question.length > 7 ? 'text-[10px] md:text-base' : 
                                                  'text-xs md:text-lg'}
                                            `}>
                                                {prob.question}
                                            </span>
                                        )}
                                    </div>
                                ))}
                                {answers.map(ans => ans.currentSlot !== null && (
                                    <div key={ans.id} 
                                        style={{ position: 'absolute', left: problems.find(p=>p.id===ans.currentSlot).left, top: problems.find(p=>p.id===ans.currentSlot).top, transform: 'translate(-50%, -50%)', zIndex: 10 }}
                                        className={`w-10 h-10 md:w-16 md:h-16 rounded-full flex items-center justify-center text-lg md:text-2xl font-bold shadow-lg bg-gradient-to-br ${ans.colorStyle.bg} text-white border-2 ${ans.colorStyle.border} pointer-events-none`}>
                                        {ans.value}
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="hidden md:flex w-1/4 h-full flex-col items-center justify-center gap-4 py-4 z-20 touch-none">
                            <div className="flex flex-col gap-3 w-full items-center overflow-y-auto hide-scrollbar pb-20">
                                {unplacedAnswers.filter((_, i) => i % 2 !== 0).map(ans => (
                                    <DraggableBall key={ans.id} ans={ans} draggedItem={draggedItem} onDown={handlePointerDown} />
                                ))}
                            </div>
                        </div>

                        <div className="md:hidden w-full h-[35%] bg-slate-800/50 border-t border-white/10 flex flex-col z-20 touch-pan-x">
                            <div className="text-white/50 text-xs text-center py-1">ÊãñÊõ≥ÂΩ©ÁêÉÂà∞Ê®π‰∏ä</div>
                            <div className="flex-1 w-full overflow-x-auto overflow-y-hidden flex items-center px-4 gap-4 hide-scrollbar touch-pan-x">
                                {unplacedAnswers.map(ans => (
                                    <DraggableBall key={ans.id} ans={ans} draggedItem={draggedItem} onDown={handlePointerDown} mobile={true} />
                                ))}
                            </div>
                        </div>

                        {draggedItem && (
                             <div style={{ position: 'fixed', left: dragPosition.x, top: dragPosition.y, transform: 'translate(-50%, -50%) scale(1.2)', zIndex: 100, pointerEvents: 'none' }}
                                className={`w-14 h-14 md:w-16 md:h-16 rounded-full flex items-center justify-center text-2xl font-bold shadow-2xl ring-4 ring-white bg-gradient-to-br ${answers.find(a => a.id === draggedItem)?.colorStyle.bg} text-white`}>
                                {answers.find(a => a.id === draggedItem)?.value}
                            </div>
                        )}
                    </div>

                    {completed && (
                        <div className="absolute inset-0 bg-black/70 z-50 flex items-center justify-center p-4 backdrop-blur-sm animate-fade-in">
                            <div className="bg-white rounded-3xl p-6 md:p-8 max-w-md w-full text-center shadow-2xl border-8 border-green-500 animate-bounce-short">
                                <Trophy size={64} className="mx-auto text-yellow-500 mb-4" />
                                <h2 className="text-2xl md:text-3xl font-black text-slate-800 mb-2">Â§™Ê£í‰∫ÜÔºÅ</h2>
                                <p className="text-slate-600 mb-4">‰Ω†ÊàêÂäüË£ùÈ£æ‰∫ÜËÅñË™ïÊ®πÔºÅ</p>
                                <button onClick={startNewGame} className="bg-green-600 text-white text-xl font-bold py-3 px-8 rounded-full shadow-lg">ÂÜç‰æÜ‰∏ÄÊ¨°</button>
                            </div>
                        </div>
                    )}

                    {feedback && (
                        <div className="absolute top-20 pointer-events-none z-50 animate-ping w-full text-center">
                            {feedback === 'correct' ? (
                                <span className="text-green-400 text-4xl font-black drop-shadow-md">‚úì Ê≠£Á¢∫</span>
                            ) : (
                                <span className="text-red-500 text-4xl font-black drop-shadow-md">‚úï ÂÜçË©¶Ë©¶</span>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        const DraggableBall = ({ ans, draggedItem, onDown, mobile = false }) => {
            const isBeingDragged = ans.id === draggedItem;
            // Calculate font size class
            const valStr = ans.value.toString();
            const fontSizeClass = valStr.length > 4 ? "text-sm md:text-lg" : 
                                  valStr.length > 3 ? "text-base md:text-xl" : 
                                  "text-lg md:text-2xl";

            return (
                <div onMouseDown={(e) => onDown(e, ans.id)} onTouchStart={(e) => onDown(e, ans.id)}
                    style={{ opacity: isBeingDragged ? 0 : 1, touchAction: 'none' }}
                    className={`${mobile ? 'w-14 h-14 min-w-[3.5rem]' : 'w-12 h-12 md:w-16 md:h-16'} ${fontSizeClass} rounded-full flex items-center justify-center font-bold shadow-[0_4px_0_rgb(0,0,0,0.2)] cursor-grab bg-gradient-to-br ${ans.colorStyle.bg} text-white border-2 ${ans.colorStyle.border} transition-opacity duration-200 shrink-0 select-none`}>
                    {ans.value}
                    <div className="absolute -top-1 w-1 h-3 bg-yellow-600/50 rounded-full"></div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MathTreeGame />);
    </script>
</body>
</html>