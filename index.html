<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <title>üéÑ ËÅñË™ïÊï∏Â≠∏Ê®π - Âø´Ê®ÇÂ≠∏Êï∏Â≠∏</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #0f172a; overscroll-behavior: none; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes bounce-short {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -60%) scale(1.1); }
        }
        .animate-bounce-short { animation: bounce-short 0.5s ease-in-out; }
        .cursor-grab { cursor: grab; }
        .cursor-grabbing { cursor: grabbing; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const RefreshCw = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
        );
        const Trophy = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M12 14.66V17"/><path d="M12 2v20"/><path d="M12 17a5 5 0 0 1-5-5V7h10v5a5 5 0 0 1-5 5Z"/></svg>
        );
        const Star = ({ size = 24, fill = "none", color = "currentColor", strokeWidth = 2, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke={color} strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>
        );
        const Wand2 = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2.36 18.64a1.21 1.21 0 0 0 0 1.72l1.28 1.28a1.2 1.2 0 0 0 1.72 0L21.64 5.36a1.2 1.2 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></svg>
        );
        const X = ({ size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M18 6 6 18"/><path d="m6 6 18 18"/></svg>
        );

        // --- Main Component ---
        const MathTreeGame = () => {
            const [level, setLevel] = useState(1);
            const [problems, setProblems] = useState([]);
            const [answers, setAnswers] = useState([]);
            const [completed, setCompleted] = useState(false);
            const [draggedItem, setDraggedItem] = useState(null);
            const [dragPosition, setDragPosition] = useState({ x: 0, y: 0 });
            const [feedback, setFeedback] = useState(null);
            
            // New Refs for Touch Handling
            const dragStartPos = useRef({ x: 0, y: 0 });
            const pendingDrag = useRef(null);
            
            // AI State
            const [showAIModal, setShowAIModal] = useState(false);
            const [aiPrompt, setAiPrompt] = useState("Áµ¶Êàë 10 È°åÈÅ©ÂêàÂ∞èÂ≠∏‰∏ÄÂπ¥Á¥öÁöÑÂä†Ê∏õÊ≥ï");
            const [isGenerating, setIsGenerating] = useState(false);
            const [aiWinMessage, setAiWinMessage] = useState("");
            const [aiError, setAiError] = useState("");
            const [debugInfo, setDebugInfo] = useState(null); // Áî®‰æÜÈ°ØÁ§∫Ë©≥Á¥∞ÈåØË™§

            const treeRef = useRef(null);
            const slotRefs = useRef({});

            // ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è Ë´ãÂú®ÈÄôË£°Â°´ÂÖ•ÊÇ®ÁöÑ Google Gemini API Key ‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è
            const apiKey = "AIzaSyCWqG9d57-v8BorhZjmtJVy88vKIYsiZVs"; 

            // Configuration
            const TREE_SLOTS_POS = [
                { id: 0, top: '20%', left: '50%' },
                { id: 1, top: '35%', left: '40%' },
                { id: 2, top: '35%', left: '60%' },
                { id: 3, top: '50%', left: '30%' },
                { id: 4, top: '50%', left: '50%' },
                { id: 5, top: '50%', left: '70%' },
                { id: 6, top: '68%', left: '20%' },
                { id: 7, top: '68%', left: '40%' },
                { id: 8, top: '68%', left: '60%' },
                { id: 9, top: '68%', left: '80%' },
            ];

            const BALL_STYLES = [
                { bg: 'from-red-400 to-red-600', border: 'border-red-300' },
                { bg: 'from-blue-400 to-blue-600', border: 'border-blue-300' },
                { bg: 'from-green-400 to-green-600', border: 'border-green-300' },
                { bg: 'from-purple-400 to-purple-600', border: 'border-purple-300' },
                { bg: 'from-orange-400 to-orange-600', border: 'border-orange-300' },
                { bg: 'from-pink-400 to-pink-600', border: 'border-pink-300' },
                { bg: 'from-teal-400 to-teal-600', border: 'border-teal-300' },
                { bg: 'from-indigo-400 to-indigo-600', border: 'border-indigo-300' },
                { bg: 'from-rose-400 to-rose-600', border: 'border-rose-300' },
                { bg: 'from-cyan-400 to-cyan-600', border: 'border-cyan-300' },
            ];

            useEffect(() => {
                startNewGame();
            }, [level]);

            // --- Gemini API Logic (Diagnostic Mode) ---
            const callGemini = async (prompt, systemInstruction = "") => {
                setDebugInfo(null);
                
                if (!apiKey) {
                    alert("Ë´ãÂÖàÂú®Á®ãÂºèÁ¢º‰∏≠Ë®≠ÂÆöÊÇ®ÁöÑ Google API KeyÔºÅ");
                    throw new Error("No API Key");
                }
                
                try {
                    console.log("Starting API call...");
                    // Try to log the key length to confirm it's loaded (without revealing full key)
                    console.log(`Key loaded: ${apiKey.substring(0, 4)}... (Length: ${apiKey.length})`);

                    const response = await fetch(
                        `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                contents: [{ parts: [{ text: prompt }] }],
                                systemInstruction: { parts: [{ text: systemInstruction }] },
                                generationConfig: { responseMimeType: "application/json" }
                            }),
                        }
                    );
                    
                    if (!response.ok) {
                        // ÂèñÂæóË©≥Á¥∞ÈåØË™§Ë®äÊÅØÊñáÂ≠ó
                        const errorText = await response.text();
                        console.error("API Failed Response:", errorText);
                        
                        // È°ØÁ§∫Âú®Áï´Èù¢‰∏ä‰æõË®∫Êñ∑
                        let errorJson;
                        try {
                           errorJson = JSON.parse(errorText);
                        } catch(e) {
                           errorJson = { message: errorText };
                        }
                        
                        const detailedError = `Status: ${response.status}\nMessage: ${errorJson.error?.message || errorText}`;
                        setDebugInfo(detailedError);
                        
                        throw new Error(detailedError);
                    }
                    
                    const data = await response.json();
                    return JSON.parse(data.candidates[0].content.parts[0].text);
                } catch (error) {
                    console.error("Gemini API Error:", error);
                    // Â¶ÇÊûúÊ≤íÊúâË¢´‰∏äÈù¢ÊîîÊà™Âà∞Ôºà‰æãÂ¶ÇÁ∂≤Ë∑ØÊñ∑Á∑öÔºâÔºåÈÄôË£°‰πüÊúÉÊçïÊçâ
                    if (!debugInfo) setDebugInfo(error.message);
                    throw error;
                }
            };

            const generateAILevel = async () => {
                if (!aiPrompt.trim()) return;
                setIsGenerating(true);
                setAiError("");
                
                const systemPrompt = `
                  Generate exactly 10 unique math problems (e.g. "5 + 3").
                  Return JSON: { "problems": [{ "num1": 5, "operator": "+", "num2": 3, "answer": 8 }, ...] }
                  CRITICAL: All 10 'answer' values MUST be unique.
                  Difficulty based on user request.
                `;

                try {
                    const result = await callGemini(aiPrompt, systemPrompt);
                    if (result && result.problems && result.problems.length > 0) {
                        setupGameFromData(result.problems.slice(0, 10));
                        setShowAIModal(false);
                    } else {
                        setAiError("AI ÂõûÂÇ≥‰∫ÜÁ©∫Ë≥áÊñô");
                    }
                } catch (e) {
                    // Error is already handled in debugInfo
                    setAiError("ÁôºÁîüÈåØË™§ÔºåË´ãÊü•Áúã‰∏ãÊñπÁ¥ÖËâ≤Ë®∫Êñ∑Ë®äÊÅØ üëá");
                } finally {
                    setIsGenerating(false);
                }
            };

            // (AI Win Message function omitted for brevity in diag mode, same logic applies)
             const fetchAIWinMessage = async () => { /* ... */ };

            // --- Game Logic ---
            const setupGameFromData = (dataList) => {
                const newProblems = [];
                const newAnswers = [];
                const shuffledColors = [...BALL_STYLES].sort(() => 0.5 - Math.random());

                dataList.forEach((item, i) => {
                    if (i >= 10) return; 
                    newProblems.push({
                        id: i,
                        question: `${item.num1} ${item.operator} ${item.num2}`,
                        answer: item.answer,
                        solved: false,
                        ...TREE_SLOTS_POS[i]
                    });
                    newAnswers.push({
                        id: `ans-${i}`,
                        value: item.answer,
                        problemId: i,
                        currentSlot: null,
                        isDragging: false,
                        colorStyle: shuffledColors[i % shuffledColors.length],
                    });
                });

                setProblems(newProblems);
                setAnswers(newAnswers);
                setCompleted(false);
                setFeedback(null);
                setAiWinMessage("");
            };

            const startNewGame = () => {
                const newProblems = [];
                const newAnswers = [];
                const usedAnswers = new Set();
                const shuffledColors = [...BALL_STYLES].sort(() => 0.5 - Math.random());

                for (let i = 0; i < 10; i++) {
                    let num1, num2, operator, answer;
                    do {
                        operator = Math.random() > 0.5 ? '+' : '-';
                        if (operator === '+') {
                            num1 = Math.floor(Math.random() * 10) + 1; 
                            num2 = Math.floor(Math.random() * 10) + 1;
                            answer = num1 + num2;
                        } else {
                            num1 = Math.floor(Math.random() * 15) + 5;
                            num2 = Math.floor(Math.random() * (num1 - 1)) + 1;
                            answer = num1 - num2;
                        }
                    } while (usedAnswers.has(answer));

                    usedAnswers.add(answer);
                    newProblems.push({
                        id: i,
                        question: `${num1} ${operator} ${num2}`,
                        answer: answer,
                        solved: false,
                        ...TREE_SLOTS_POS[i]
                    });
                    newAnswers.push({
                        id: `ans-${i}`,
                        value: answer,
                        problemId: i,
                        currentSlot: null,
                        isDragging: false,
                        colorStyle: shuffledColors[i % shuffledColors.length],
                    });
                }

                setProblems(newProblems);
                setAnswers(newAnswers);
                setCompleted(false);
                setFeedback(null);
                setAiWinMessage("");
            };

            // --- Drag and Drop ---
            const handlePointerDown = (e, answerId) => {
                if (!e.touches) {
                    e.preventDefault();
                    setDraggedItem(answerId);
                    setDragPosition({ x: e.clientX, y: e.clientY });
                    setAnswers(prev => prev.map(a => a.id === answerId ? { ...a, isDragging: true } : a));
                    return;
                }
                const touch = e.touches[0];
                dragStartPos.current = { x: touch.clientX, y: touch.clientY };
                pendingDrag.current = answerId;
            };

            const handlePointerMove = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                if (draggedItem) {
                    if (e.cancelable) e.preventDefault(); 
                    setDragPosition({ x: clientX, y: clientY });
                    return;
                }

                if (pendingDrag.current && e.touches) {
                    const startX = dragStartPos.current.x;
                    const startY = dragStartPos.current.y;
                    const deltaX = Math.abs(clientX - startX);
                    const deltaY = Math.abs(clientY - startY);

                    if (deltaX > 5 || deltaY > 5) {
                        if (deltaY > deltaX) {
                             if (e.cancelable) e.preventDefault();
                             const ansId = pendingDrag.current;
                             setDraggedItem(ansId);
                             setDragPosition({ x: clientX, y: clientY });
                             setAnswers(prev => prev.map(a => a.id === ansId ? { ...a, isDragging: true } : a));
                             pendingDrag.current = null;
                        } else {
                            pendingDrag.current = null;
                        }
                    }
                }
            };

            const handlePointerUp = (e) => {
                pendingDrag.current = null; 
                
                if (!draggedItem) return;

                const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
                const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
                
                let targetSlotId = null;
                Object.keys(slotRefs.current).forEach((key) => {
                    const slotEl = slotRefs.current[key];
                    if (slotEl) {
                        const rect = slotEl.getBoundingClientRect();
                        const distance = Math.hypot(
                            rect.x + rect.width / 2 - clientX,
                            rect.y + rect.height / 2 - clientY
                        );
                        if (distance < 50) targetSlotId = parseInt(key);
                    }
                });

                if (targetSlotId !== null) {
                    checkAnswer(draggedItem, targetSlotId);
                } else {
                    resetDrag(draggedItem);
                }
                setDraggedItem(null);
            };

            const resetDrag = (id) => {
                setAnswers(prev => prev.map(a => a.id === id ? { ...a, isDragging: false } : a));
            };

            const checkAnswer = (ansId, slotId) => {
                const answerObj = answers.find(a => a.id === ansId);
                const problemObj = problems.find(p => p.id === slotId);

                if (problemObj.solved) {
                    resetDrag(ansId);
                    return;
                }

                if (answerObj.value === problemObj.answer) {
                    // Success logic...
                    setAnswers(prev => prev.map(a => 
                        a.id === ansId ? { ...a, isDragging: false, currentSlot: slotId } : a
                    ));
                    setProblems(prev => prev.map(p => 
                        p.id === slotId ? { ...p, solved: true } : p
                    ));
                    setFeedback('correct');
                    setTimeout(() => setFeedback(null), 1000);
                } else {
                    setFeedback('wrong');
                    setTimeout(() => setFeedback(null), 1000);
                    resetDrag(ansId);
                }
            };

            useEffect(() => {
                if (problems.length > 0 && problems.every(p => p.solved)) {
                    setCompleted(true);
                }
            }, [problems]);

            // Layout Helpers
            const unplacedAnswers = answers.filter(a => a.currentSlot === null);

            return (
                <div 
                    className="w-full h-screen bg-slate-900 overflow-hidden flex flex-col items-center select-none"
                    onTouchMove={handlePointerMove}
                    onTouchEnd={handlePointerUp}
                    onMouseMove={handlePointerMove}
                    onMouseUp={handlePointerUp}
                >
                    {/* Background */}
                    <div className="absolute inset-0 pointer-events-none opacity-20">
                         {/* Snow... */}
                    </div>

                    {/* Header */}
                    <div className="z-10 w-full p-2 md:p-4 flex justify-between items-center bg-slate-800/80 text-white shadow-lg border-b border-white/10 shrink-0">
                        <h1 className="text-lg md:text-2xl font-bold flex items-center gap-2 text-green-400">
                            <span className="text-xl md:text-2xl">üéÑ</span> 
                            <span className="hidden md:inline">ËÅñË™ïÊï∏Â≠∏Ê®π</span>
                            <span className="md:hidden">Êï∏Â≠∏Ê®π</span>
                        </h1>
                        <div className="flex gap-2">
                            <button 
                                onClick={() => setShowAIModal(true)}
                                className="flex items-center gap-1 md:gap-2 px-3 py-1.5 bg-indigo-600 hover:bg-indigo-500 rounded-full font-bold shadow-md text-xs md:text-base"
                            >
                                <Wand2 size={16} /> AIÂá∫È°å
                            </button>
                            <button 
                                onClick={startNewGame}
                                className="flex items-center gap-1 md:gap-2 px-3 py-1.5 bg-red-600 hover:bg-red-500 rounded-full font-bold shadow-md text-xs md:text-base"
                            >
                                <RefreshCw size={16} /> ÈáçÁé©
                            </button>
                        </div>
                    </div>

                    {/* Main Game Area */}
                    <div className="flex-1 w-full max-w-6xl flex flex-col md:flex-row relative overflow-hidden">
                        
                        {/* Desktop Left */}
                        <div className="hidden md:flex w-1/4 h-full flex-col items-center justify-center gap-4 py-4 z-20 touch-none">
                            <div className="flex flex-col gap-3 w-full items-center overflow-y-auto hide-scrollbar pb-20">
                                {unplacedAnswers.filter((_, i) => i % 2 === 0).map(ans => (
                                    <DraggableBall key={ans.id} ans={ans} draggedItem={draggedItem} onDown={handlePointerDown} />
                                ))}
                            </div>
                        </div>

                        {/* Center Tree */}
                        <div className="w-full md:w-2/4 h-[65%] md:h-full relative flex items-center justify-center shrink-0 touch-none" ref={treeRef}>
                            <div className="relative w-full h-full max-h-[80vh] aspect-[2/3] md:aspect-[2/3] flex items-center justify-center">
                                {/* Star, SVG Tree, Slots... */}
                                <div className={`absolute top-[8%] left-1/2 -translate-x-1/2 z-10 transition-all duration-500 ${completed ? 'scale-150 drop-shadow-[0_0_20px_rgba(255,255,0,0.8)]' : 'scale-100'}`}>
                                    <Star size={40} fill={completed ? "gold" : "#fbbf24"} color="#b45309" strokeWidth={2} className="animate-pulse" />
                                </div>
                                <svg viewBox="0 0 200 300" className="w-full h-full drop-shadow-2xl">
                                    <path d="M100 20 L 10 250 L 190 250 Z" fill="#15803d" stroke="#14532d" strokeWidth="3" />
                                    <path d="M30 200 Q 100 220 170 200" fill="none" stroke="#fbbf24" strokeWidth="2" strokeDasharray="5,5" opacity="0.6"/>
                                    <path d="M55 140 Q 100 160 145 140" fill="none" stroke="#fbbf24" strokeWidth="2" strokeDasharray="5,5" opacity="0.6"/>
                                    <path d="M75 80 Q 100 90 125 80" fill="none" stroke="#fbbf24" strokeWidth="2" strokeDasharray="5,5" opacity="0.6"/>
                                    <rect x="85" y="250" width="30" height="40" fill="#78350f" />
                                </svg>
                                {problems.map(prob => (
                                    <div key={prob.id} ref={el => slotRefs.current[prob.id] = el}
                                        className={`absolute w-12 h-12 md:w-20 md:h-20 rounded-full flex items-center justify-center text-center transform -translate-x-1/2 -translate-y-1/2 border-[3px] md:border-4 transition-all duration-300 ${prob.solved ? 'bg-yellow-100 border-yellow-400' : 'bg-green-800/80 border-green-600'}`}
                                        style={{ top: prob.top, left: prob.left }}>
                                        {!prob.solved && <span className="text-white font-bold text-xs md:text-lg drop-shadow-md whitespace-nowrap">{prob.question}</span>}
                                    </div>
                                ))}
                                {answers.map(ans => ans.currentSlot !== null && (
                                    <div key={ans.id} 
                                        style={{ position: 'absolute', left: problems.find(p=>p.id===ans.currentSlot).left, top: problems.find(p=>p.id===ans.currentSlot).top, transform: 'translate(-50%, -50%)', zIndex: 10 }}
                                        className={`w-10 h-10 md:w-16 md:h-16 rounded-full flex items-center justify-center text-lg md:text-2xl font-bold shadow-lg bg-gradient-to-br ${ans.colorStyle.bg} text-white border-2 ${ans.colorStyle.border} pointer-events-none`}>
                                        {ans.value}
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Desktop Right */}
                        <div className="hidden md:flex w-1/4 h-full flex-col items-center justify-center gap-4 py-4 z-20 touch-none">
                            <div className="flex flex-col gap-3 w-full items-center overflow-y-auto hide-scrollbar pb-20">
                                {unplacedAnswers.filter((_, i) => i % 2 !== 0).map(ans => (
                                    <DraggableBall key={ans.id} ans={ans} draggedItem={draggedItem} onDown={handlePointerDown} />
                                ))}
                            </div>
                        </div>

                        {/* Mobile Bottom */}
                        <div className="md:hidden w-full h-[35%] bg-slate-800/50 border-t border-white/10 flex flex-col z-20 touch-pan-x">
                            <div className="text-white/50 text-xs text-center py-1">ÊãñÊõ≥ÂΩ©ÁêÉÂà∞Ê®π‰∏ä</div>
                            <div className="flex-1 w-full overflow-x-auto overflow-y-hidden flex items-center px-4 gap-4 hide-scrollbar touch-pan-x">
                                {unplacedAnswers.map(ans => (
                                    <DraggableBall key={ans.id} ans={ans} draggedItem={draggedItem} onDown={handlePointerDown} mobile={true} />
                                ))}
                            </div>
                        </div>

                        {/* Dragging Portal */}
                        {draggedItem && (
                             <div style={{ position: 'fixed', left: dragPosition.x, top: dragPosition.y, transform: 'translate(-50%, -50%) scale(1.2)', zIndex: 100, pointerEvents: 'none' }}
                                className={`w-14 h-14 md:w-16 md:h-16 rounded-full flex items-center justify-center text-2xl font-bold shadow-2xl ring-4 ring-white bg-gradient-to-br ${answers.find(a => a.id === draggedItem)?.colorStyle.bg} text-white`}>
                                {answers.find(a => a.id === draggedItem)?.value}
                            </div>
                        )}
                    </div>

                    {/* AI Modal */}
                    {showAIModal && (
                        <div className="absolute inset-0 bg-black/80 z-50 flex items-center justify-center p-4 backdrop-blur-md">
                            <div className="bg-slate-800 rounded-2xl w-full max-w-lg p-6 border border-indigo-500 shadow-2xl relative">
                                <div className="flex justify-between items-center mb-4">
                                    <h2 className="text-xl font-bold text-indigo-400 flex items-center gap-2">AI È≠îÊ≥ïÂá∫È°å</h2>
                                    <button onClick={() => setShowAIModal(false)} className="text-slate-400"><X size={24} /></button>
                                </div>
                                <textarea value={aiPrompt} onChange={(e) => setAiPrompt(e.target.value)} className="w-full h-32 bg-slate-900 border border-slate-700 rounded-lg p-4 text-white mb-4" placeholder="Ëº∏ÂÖ•‰Ω†ÁöÑÂá∫È°åË¶ÅÊ±Ç..." />
                                
                                {/* üî¥ Debug Info Box */}
                                {debugInfo && (
                                    <div className="mb-4 p-3 bg-red-900/80 border border-red-500 rounded text-red-200 text-xs font-mono break-all whitespace-pre-wrap h-32 overflow-y-auto">
                                        <strong>ÈåØË™§Ë®∫Êñ∑:</strong><br/>
                                        {debugInfo}
                                    </div>
                                )}
                                {aiError && !debugInfo && <div className="text-red-400 text-sm mb-4 font-bold">{aiError}</div>}
                                
                                <button onClick={generateAILevel} disabled={isGenerating} className="w-full py-3 bg-indigo-600 rounded-lg font-bold text-white">
                                    {isGenerating ? '‚è≥ ÁîüÊàê‰∏≠...' : '‚ú® ÁîüÊàêÈóúÂç°'}
                                </button>
                            </div>
                        </div>
                    )}
                    
                    {/* Completion Modal... */}
                    {/* Feedback... */}
                </div>
            );
        };

        const DraggableBall = ({ ans, draggedItem, onDown, mobile = false }) => {
            const isBeingDragged = ans.id === draggedItem;
            return (
                <div onMouseDown={(e) => onDown(e, ans.id)} onTouchStart={(e) => onDown(e, ans.id)}
                    style={{ opacity: isBeingDragged ? 0 : 1, touchAction: 'none' }}
                    className={`${mobile ? 'w-14 h-14 text-xl min-w-[3.5rem]' : 'w-12 h-12 md:w-16 md:h-16 text-xl md:text-2xl'} rounded-full flex items-center justify-center font-bold shadow-[0_4px_0_rgb(0,0,0,0.2)] cursor-grab bg-gradient-to-br ${ans.colorStyle.bg} text-white border-2 ${ans.colorStyle.border} transition-opacity duration-200 shrink-0 select-none`}>
                    {ans.value}
                    <div className="absolute -top-1 w-1 h-3 bg-yellow-600/50 rounded-full"></div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<MathTreeGame />);
    </script>
</body>
</html>